(-)indexOf() 方法可返回某个指定的字符串值在字符串(数组)中首次出现的位置。在则返回所在字符串（数组）下标；不在则返回-1
var arr=['mounted','component','bus']
        var str='abcd'
        console.log(str.indexOf('c'));//2
        console.log(str.indexOf('e'));//-1
        console.log(arr.indexOf('bus'));//2
        console.log(arr.indexOf('c'));//-1
1变异方法改变原始数组
（1）splice
splice() 方法向/从数组添加/删除项目，并返回删除的项目。
array.splice(index, howmany, item1, ....., itemX)
index	必需。整数，指定在什么位置添加/删除项目，使用负值指定从数组末尾开始的位置。
howmany	可选。要删除的项目数。如果设置为 0，则不会删除任何项目。
item1, ..., itemX	可选。要添加到数组中的新项目。
（2）pop
2.非变异字符串方法slice,不改变原字符串,如果某个参数为负，则从字符串的结尾开始计数.不包含结束位置
var str='hello';
var a=str.slice(0,-1);
console.log(a);//hell
str=a;
(3)push() 方法将新元素添加到数组的结尾
(4)unshift() 方法将新元素添加到数组的开头。
substr() 类似于 slice()。
不同之处在于第二个参数规定被提取部分的长度（截多少位）
(5)第一个参数（2）定义了应添加新元素的位置（拼接）。
第二个参数（0）定义应删除多少元素。
其余参数（“Lemon”，“Kiwi”）定义要添加的新元素。
splice() 方法返回一个包含已删除项的数组：

var arr=['mounted','component','bus']
        /* console.log(arr.pop());//bus 从数组中删除最后一个元素
        console.log(arr);//['mounted', 'component'] */
        // console.log(arr.toString());//mounted,component,bus 返回以逗号分隔的字符串
        // console.log(arr.join(' '));//mounted component bus
        console.log(arr.splice(1,2,'check'));//['component', 'bus']
        console.log(arr);//['mounted', 'check']
        // console.log(arr.splice(2));//['bus']
        // console.log(arr.shift());//mounted
---------------------------------------------------------------------------------------------
1.typeof :检测当前的数据类型的；
首先返回一个字符串，字符串中包 含当前值所对应的数据类型；
只能检测基本数据类型，不能区分对象数据类型下具体的对象数组正则；
复制代码
console.log(typeof 1);// "number"
console.log(typeof "1");// "string"
console.log(typeof true);// "boolean"
console.log(typeof null);// "object"
console.log(typeof undefined);// "undefined"
console.log(typeof {});//"object"
console.log(typeof []);//"object"
console.log(typeof /\d/);//"object"
console.log(typeof function(){});//"function"
2.isNaN : 强制转换成number，在判断
isNaN 这个方法执行时，会先把要校验的值强制转换成number类型的；然后再进行判断；
如果当前是一个有效的数字，那么返回false；
如果不是一个有效的数字，返回结果true；
console.log(isNaN(17));//false
console.log(isNaN(1));//false
console.log(isNaN(NaN));//true
console.log(isNaN("1px"));//true
console.log(isNaN("1"));//false
3.Number :将其他数据类型的值强制转换成number类型；
要把其他数据类型转换成number时，首先会调用toString；
复制代码
console.log(Number("1px"));//NaN
console.log(Number("1"));//1
console.log(Number({}));//NaN
console.log(Number(null));// 0
console.log(Number(undefined));// NaN
console.log(Number([]));// 0
console.log(Number(""));// 0
console.log(Number(true));// 1
console.log(Number(false));//0
4.parseInt :经常用于字符串提取数字的方法；
把字符串中从左到右依次识别，直到遇到一个非有效数字，停止，把找到的数字返回；
如果第一个字符是非有效数字，那么直接返回NaN;
复制代码
console.log(parseInt("12px12"));// 12
console.log(parseInt("12.666.777px12"));// 12
console.log(parseInt("px12.666px12"));// NaN
console.log(parseInt(""));// NaN
console.log(parseInt(true));// NaN
console.log(parseInt({}));// NaN
console.log(parseInt([]));// NaN
console.log(parseInt(null));// NaN
console.log(parseInt(undefined));// NaN
5.parseFloat:和parseInt 用法一样；区别是多识别一位小数点
console.log(parseFloat("12.666.7777px12"));//12.666
6.toFixed : 保留小数点位数的方法;返回值是一个字符串；
var num = 3.13244;
console.log(num.toFixed(2));//3.13
console.log(num.toFixed(0));

 <script src="../lib/jquery-3.4.1.min.js"></script>
</head>
<body>
    <input type="text" value="1">
    <script>
        $('input').on('input',function(){//input事件监听输入框数字的变化
            // console.log(123);//如果输入框数字有变化，弹出123
            //console.log(typeof($(this).val()));//string
            console.log(Number($(this).val()));//如果是数字就弹出数字，不是数字弹出NaN
            /* if( $(this).val() !== '' && !Number($(this).val()) ){
                $(this).val(1);//不为空和不是数字走这
            } */
        })
        if(NaN){//false
            console.log(111);//不弹
        }
        if(!NaN){
            console.log(222);//弹
        }
    </script>

previousElementSibling上一个兄弟节点
nextElementSibling下一个兄弟节点
offsetTop页面可看见距离
pageXOffset 和 pageYOffset 属性返回文档在窗口左上角水平和垂直方向滚动的像素，这些属性是只读的

Element.getBoundingClientRect()
Element.offsetTop
差别大了，前者指元素（比如某个div）距离可视区域顶部的距离，后者包括滚动条卷起的部分。

getBoundingClientRect().top
	<div id="box"></div>
var div=document.getElementById('box');  
rectObject = div.getBoundingClientRect();
 
	rectObject.top：元素上边到视窗上边的距离;
	rectObject.right：元素右边到视窗左边的距离;
	rectObject.bottom：元素下边到视窗上边的距离;
	rectObject.left：元素左边到视窗左边的距离;
	rectObject.width：是元素自身的宽
	rectObject.height是元素自身的高
	获取自定义属性
	Element.getBoundingClientRect() 方法返回元素的大小及其相对于视口的位置。
如果是标准盒子模型，元素的尺寸等于width/height + padding + border-width
offsetTop元素到offsetParent顶部的距离

window.location.reload() //刷新

window.history.go(1) //前进

window.history.go(-1) //后退

window.history.forward() //前进

window.history.back() 后退+刷新
onload 加载事件
window.onload = function(){等页面都加载完后触发这里代码}
addEventListener() : 添加事件的另一种写法
        document.addEventListener('DOMContentLoaded',function(){
            console.log(2);
        })
DOMContentLoaded : DOM加载事件}
1. return返回null，起到中断方法执行的效果，只要不return false事件处理函数将会继续执行，表单将提交
2. return false，事件处理函数会取消事件，不再继续向下执行。比如表单将终止提交。
<form action="index.jsp" method="post" onsubmit="return submitTest();">
    <INPUT value="www">
    <input type="submit" value="submit">
</form>

<script>
    function submitTest() {
        return;
    }    
</script>
charAt() 方法可返回指定位置的字符。
var str="Hello world!"
document.write(str.charAt(1))//e

return   代表调到函数外，

return 0代表函数正常终止

return 1代表函数非正常终止

let age=2;
let username='xiaoming';
let salary='1000';

var obj={//对象字面量
	age,
	username,
	salary,
};
console.log(obj);//{age:2,username:'xiaoming',salary:1000}

ES6面向对象
class Foo{
	constructor(num){
		this.username='li',
		this.age=num;
	}
	speak(){};
	run(){};
}
var b=new Foo(20);
console.log(c.age);//20
class People extends Foo{//子类
		constructor(){
		super(123);//修正this指向子类
		this.gender='male';
		}
		sing(){}
}

ES5面向对象

冒泡排序：让数组当前项和后一项进行比较，小的放在前面，大的放在后面


Event对象属性与方法
        event;代表事件本身
        event.type;代表事件类型；如：click
        event.target;表示触发事件的源头，通俗理解：点击谁触发了事件，target就是谁
        event.currentTarget;表示包含事件的元素；通俗理解：事件绑定在谁身上，currentTarget就是谁
        event.preventDefault();阻止默认行为；如阻止a标签的链接跳转
        event.stopPropagation();阻止事件冒泡和事件捕获
        clientX/clientY;触发事件时鼠标位于浏览器窗口的固定X/Y轴坐标，不受滚动条影响；
        pageX/pageY;触发事件时鼠标位于浏览器窗口的X/Y轴坐标，受滚动条影响；
        screenX/screenY;触发事件时鼠标位于屏幕的X/Y轴坐标；
对象属性访问方式：obj.name或obj["name"]


enctype：规定了form表单在发送到服务器时候编码方式，有如下的三个值。

1、application/x-www-form-urlencoded。默认的编码方式。但是在用文本的传输和MP3等大型文件的时候，使用这种编码就显得 效率低下。 
2、multipart/form-data 。 指定传输数据为二进制类型，比如图片、mp3、文件。 
3、text/plain。纯文体的传输。空格转换为 “+” 加号，但不对特殊字符编码。
在Form元素的语法中，EncType表明提交数据的格式

用 Enctype 属性指定将数据回发到服务器时浏览器使用的编码类型。

application/x-www-form-urlencoded：窗体数据被编码为名称/值对。这是标准的编码格式。

multipart/form-data：窗体数据被编码为一条消息，页上的每个控件对应消息中的一个部分。

text/plain：窗体数据以纯文本形式进行编码，其中不含任何控件或格式字符
-----------------------------------------------------------------------------8.26-------------------------------------------------------------
		var a=2;
        function foo(){
            //提升作用域var a;
            console.log(a);//undefined
            //a=1;
            var a=1;
        }
        foo();//调用函数才能得到值

/* var a = 1;
        function foo(){
            var a = 2;
            console.log(a);  // 作用域链：就是从当前作用域，一层一层的向外进行查找，查超顺序就是就近原则。
        }
        foo(); */

// JS就是词法作用域 : 看函数定义的位置，而不是看函数调用的位置
        var a = 1;
        function foo(){
            var a = 2;
            bar();
        }
        function bar(){
            console.log(a);   // 1 -> 一定要根据定义函数的位置去找值，忘记调用的地方。
        }
        foo();
		
//js操作html	
//可以动态获取
// document.getElementById() : 必须是document
// document.getElementsByTagName() : 可以是document，也可以是其他元素

// 获取元素，一定是要元素在网页生产后再去获取,不能动态获取
document.querySelector('#box');
        document.querySelector('.box');
        document.querySelectorAll(); 

        
// getAttribute() : 获取自定义属性
        // setAttribute() : 设置自定义属性
        //console.log( elem.getAttribute('qianfeng') );  
        //elem.setAttribute('qianfeng', '大连千锋');

        // 在标签中，属性以 data-开头的都属于自定义属性，推荐使用这种方式添加自定义属性。
        //console.log( elem.getAttribute('data-qianfeng') );

        //console.log( elem.dataset.qianfeng );
        //elem.dataset.qianfeng = 'qf';
		
// 设置行间样式
        //elem.style.color = 'blue';
        //elem.style.fontSize = '50px';
		
//onclick : 点击事件   ( 最后触发 )
        //onmousedown : 鼠标按下事件
        //onmouseup : 鼠标抬起事件

        //ondblclick : 双击事件
        //onmouseover : 鼠标移入事件（连续触发）
        //onmouseout : 鼠标移开事件
		onmousedown
        onmouseup
        onmouseover 
        onmouseout

        /* elem.onmousedown = function(){
            console.log(1);
        };
        elem.onmouseup = function(){
            console.log(2);
        }; */

        /* elem.ondblclick = function(){
            console.log(1);
        }; */
		
---------------------------------------------------------------------------------9.8-------------------------------------------------------------
正则

---------------------------------------------------------------------------------9.11-------------------------------------------------------------
封装动画
先了解一个关于时间换算路程的公式：  s = t/d * c + b;  时间算换匀速路程的公式
        // t : 当前时间
        // d : 总时间
        // c : 变化量
        // b : 初始值（初始点距离）
		目标点距离target
		c = target - b;
		
------------------------------------------------------------------------------9.13--------------------------------------------------------------
// ES6中才真正的有类：  class 

        // ES5中没有类，有一个模拟的类： 构造函数


       /*  构造函数 : 跟普通函数很想，但是有两点比较重要的区别：
            1. 构造函数的函数名首字母要求大写，其他位置都是小写。
            2. 构造函数的函数调用前必须添加一个new关键词。

        //普通函数
        function foo(){
            this -> window
            //return 123;
        }
        var a = foo();   // undefined

        //构造函数
        function Foo(){
            
        }
        new Foo();
 */
        var key='username';
        function Foo(){
            console.log(this);  //this就是创建出来的对象
            this[key] = 'xiaoming';   // 给对象添加了一个属性
            this.age = 20;   // 给对象添加了另一个属性
            this.playGame = function(){};    // 给对象添加了一个方法
            this.program = function(){};     // 给对象添加了另一个方法

            //this.username -> 'xiaoming'
            //this.playGame(); -> 执行了方法

            //构造函数中默认有一个隐式返回
            //return this;
        }
        var f = new Foo();   // 这种写就已经创建出来了一个对象
        console.log(f.username);//xiaoming  // 可以在构造函数外得到这个对象
        console.log(f[key]);//xiaoming
        f.program();
		
------------------------------------------------------------9.14------------------------------------------------------------------------------
(1)浅拷贝
//对象的拷贝：让对象进行赋值的时候，两个对象互相不影响。
        /* var a = {
            username: 'xiaoming',
            age:20
        };
        var b = a;   //对象的引用
        b.username = 'xiaobai';
        b.age=30;
        console.log(a, b);//都是xiaobai 30 */


         /* var a = {
            username: 'xiaoming',
            age:13
        };
        var b = {};

        //通过 for in 方式来完成对象的拷贝
        for(var attr in a){//for (变量 in 对象)
            //console.log(attr);//'username','age'
            //a[attr] -> 'xiaoming'
            b[attr] = a[attr];   // 基本类型的赋值，是不会互相影响的
        }
        b.username = 'xiaobai';
        console.log(a, b); */
		
		/* var a = {
            username: 'xiaoming'
        };
        var b = Object.assign({}, a);
        //console.log(b);//{username: "xiaoming"}
        b.username = 'xiaobai';
        console.log(a, b); //{username: "xiaoming"} {username: "xiaobai"}*/

        /* var arr=[1,2,3]
        var c=Object.assign([],arr)
        console.log(c);//[1,2,3] */
		
		/* var a = [1,2,3];
        var b = [...a];//1 2 3
        b.push(4);//创建新数组
        console.log(a,b);//[1, 2, 3] ?[1, 2, 3, 4] */
//如果多少层对象嵌套在一起，再进行拷贝的时候，互相不影响，就是深拷贝
//使用for in , ... ,Object.assign(,)来进行对象拷贝的时候，只能拷贝一层，对于多层是对象的情况下，依然会互相影响。属于浅拷贝操作。
	
//递归
		function foo(n){
            if(n===1){
                return 1;  //终止条件返回1
            }
            return n * foo(n-1);
        }
        console.log( foo(4) );   // 24
        /* (1)return 4 * foo(3);(2)return 3 * foo(2);(3)return 2 * foo(1);(4)return 1
        返回(4)return 4 * 6;     (3)return 3 * 2;         (2)return 2 * 1; (1)return 1
 */
        
		
//深拷贝
/* var a = {
            username: { age: 20 }
        };

        var b = deepCopy(a);

        b.username.age = 30;

        console.log(a,b);

        function deepCopy(obj){
            var result = {};
            for(var attr in obj){
                if( typeof obj[attr] === 'object' ){
                    result[attr] = deepCopy(obj[attr]);
                }
                else{
                    result[attr] = obj[attr];
                }
            }
            return result;
        } */
		
//原型链
/* function Foo(){
            this.showName = function(){};
        }

        var f1 = new Foo();
        var f2 = new Foo();
        console.log( f1.showName );
        console.log( f2.showName );
        console.log( f1.showName == f2.showName );  // false */


        /* function Foo(){
            
        }
        Foo.prototype.showName = function(){};

        var f1 = new Foo();
        var f2 = new Foo();
        console.log( f1.showName );
        console.log( f2.showName );
        console.log( f1.showName == f2.showName );   // true */
		
function Foo(){
            this.username = 'xiaoming';//实例对象
            this.showName = function(){
                console.log(2);
            };
        }
        Foo.prototype.username = 'xiaobai';
        Foo.prototype.showName = function(){
            console.log(1);
        };
        Object.prototype.username = 'xiaoqiang';
        Object.prototype.showName = function(){
            console.log(3);
        };

        var f = new Foo();
        //f.username -> 'xiaoming'
        //f.showName(); // 可以
        console.log( f );

        //__proto__ : 就是找当前对象原型链对应的对象
        //f.__proto__ === Foo.prototype   // true
        //Foo.prototype.__proto__ === Object.prototype   // true 
        //f.__proto__.__proto__ === Object.prototype   // true
        
        /* var a = 1;
        function foo(){
            //var a = 2;
            console.log(a);
        } */


        //在面向对象开发中，不把属性放到原型下，而只把方法放到原型下。这样就不会改变原型下的所有东西，只是共享去使用
--------------------------------------------------------------------------------9.18----------------------------------------------------
// ajax技术：是跟form表单类似的能力，进行前后端数据交互。

        //     ajax技术比表单技术好的地方：
        //         1. 局部刷新的；表单是需要刷新整个页面，要跳转页面，所以要刷新整个页面。
        //         2. 异步操作的；表单跟后端通信是同步的，通信没有完成前是不能继续操作。


        // var date = new Date();
        // var re = new RegExp();
        // var arr = new Array();

        // XMLHttpRequest内置对象，创建一个叫做xhr的对象，ajax的功能都在xhr对象下完成的。
        var xhr = new XMLHttpRequest();


        // 这个事件：监听请求开始(1)到请求成功(4)的整个过程
                // 0: 请求未初始化
                // 1: 服务器连接已建立
                // 2: 请求已接收
                // 3: 请求处理中
                // 4: 请求已完成，且响应已就绪

        /* xhr.onreadystatechange = function(){
            console.log(xhr.readyState);
            // 当请求成功后，就可以拿到响应的数据了，通过xhr.responseText拿到响应的东西
            if(xhr.readyState === 4){  // 请求已完成，可以拿到响应的结果了
                xhr.responseText;
            }
        }; */

        //这个事件：只会监听请求成功的时候，也就是只有触发4这个阶段的时候
        xhr.onload = function(){
            //console.log(xhr.readyState);
            //xhr.responseText;  只要走这个事件，就100%能拿到响应的数据。
        };

        //open()和send()必须都写
        //open() 要连接的后端地址   send()发送请求数据
        xhr.open('GET', './7_data.php');
        xhr.send();
		
1.html
<script>

        /* let xhr = new XMLHttpRequest();
        xhr.onload = function(){
            //console.log(xhr.responseText);
            console.log(1);
        };
        //open() : 1参：请求方法  2参：请求url  3参：默认是true表示异步，false表示同步
        xhr.open('GET','./7_data.php', false);
        xhr.send();
        console.log(2); */

        /* let xhr = new XMLHttpRequest();
        xhr.onload = function(){
            console.log(xhr.responseText);   // php echo出来的东西
        };
        xhr.open('GET','./7_data.php');
        xhr.send(); */

        /* let xhr = new XMLHttpRequest();
        xhr.onload = function(){
            console.log(xhr.responseText);   // php echo出来的东西
        };
        //get方式发送数据，并不是通过send()，而是url。
        xhr.open('GET','./7_data.php?username=xiaoming&age=20');
        xhr.send(); */

        //响应状态码：
            // 100之间 : 响应前的状态，消息
            // 200之间 : 响应式成功的
            // 300之间 : 重定向
            // 400之间 : 客户端错误 (检查前端的代码)
            // 500之间 : 服务端错误 (检查后端的代码)
        let xhr = new XMLHttpRequest();
        xhr.onload = function(){
            if(xhr.status >= 200 && xhr.status< 400 ){  //查看状态码
                console.log(xhr.responseText);   // php echo出来的东西
            }
            else{
                console.log('客户端或服务端报错！');
            }
        };
        //get方式发送数据，并不是通过send()，而是url。
        xhr.open('GET','./2_data.php?username=xiaoming&age=20');
        xhr.send();
		
2.php
	<?php 
    $username = $_REQUEST['username'];
    $age = $_REQUEST['age'];

    echo '把接收到的数据再次响应出去：' . $username . $age;

    //echo '我是响应的数据';
?>

    </script>
	

--------------------------------------------------------------------------------9.23--------------------------------------------
//使用promise功能，就要创建promise对象
        //var p = new Promise();

        //promise中的三种状态：
            //1. pending 等待状态
            //2. fulfilled 完成状态(成功状态)
            //3. rejected 未完成状态(失败状态)

        //只有两种状态变化：而且一旦状态发生了改变就不会再变化了。
            //1. pending  ->  fulfilled
            //2. pending  ->  rejected

            // 在promise中提供了两个内置的函数，resolve()函数和reject()函数。
            
            //resolve()函数 ，函数一旦调用，就会改变状态，pending  ->  fulfilled
            //reject()函数 ，函数一旦调用，就会改变状态，pending  ->  rejected
            
//resolve()函数 -> pending  ->  fulfilled -> 会触发 promise对象下的then()方法中的回调函数
//reject()函数 -> pending  ->  rejected ->  会触发 promise对象下的catch()方法中的回调函数

        /* let p = new Promise((resolve, reject)=>{
            //当new Promise的时候，就会立即触发这里
            // console.log('xxxxx');
            resolve();  // 状态一旦改变了，就会触发then的回调函数
        });
        p.then(()=>{
            console.log(123);
        }); */

        /* let p = new Promise((resolve, reject)=>{
            setTimeout(()=>{
                reject();
            },3000)
            resolve();
        });
        p.then(()=>{
            console.log(123);   //弹出
        }).catch(()=>{
            console.log(456);   //不弹 一旦状态发生了改变就不会再变化了
        }); */

        /* let p = new Promise((resolve, reject)=>{
            setTimeout(()=>{
                //参数：只能写一个
                resolve('hello', 'hi');
            },3000)
        });
        p.then((n, m)=>{
            console.log(n);
            console.log(m);
        }).catch(()=>{
            console.log(456);
        }); */

        let p=new Promise((resolve,reject)=>{
            resolve({'username':'xiaoming','age':20});
        });
        p.then((obj)=>{
            console.log(obj.username);//'xiaoming'
            console.log(obj.age);//20
        }).catch(()=>{
            console.log(456);
        });
		
promise语法塘
async function foo(){  //这是一个针对异步操作的函数
            let ret = await bar();     // await 后面接的就是promise对象
            console.log(ret);//1 hello
            await bar();
            await bar();
            console.log(123);
        }

        function bar(){
            var p = new Promise((resolve, reject)=>{
                setTimeout(()=>{
                    console.log(1);
                    resolve('hello');
                }, 1000);
            });
            return p;
        }

        foo();  //  1秒后弹出1，再1秒弹出1，再1秒弹出1，最后弹123
------------------------------------------------------9.24------------------------------------------------------------
本地存储
//本地存储：跟数据库的功能是一样的，可以对数据进行增删改查。但是本地存储并不是把数据存储到数据库里，而是把数据存储到当前计算机的本地硬盘中。
        //本地存储可以做很多需求：比如：搜索记录、网页换肤、电子书阅读的位置、视频上一次观看的位置、游客模式
        //localStorage : 永久性存储( 一直会存储在计算机中 , 数据在当前域名下是共享的 )
        //sessionStorage : 临时性存储( 只要关闭了浏览器数据就会消失 , 数据在当前域名下是不同享的 )
        //浏览器可以查看到本地存储的具体信息：通过application选项查看到，一个域名对应一个自己的本地存储，所以不同域名之间的本地存储是互相不影响的。
        //增
        //sessionStorage.setItem('username', 'xiaoming');
        //localStorage.setItem('username', 'xiaoming');
        //删
        //localStorage.removeItem('username');
        localStorage.clear();   // 删除当前域名下的所有本地存储数据
        //改
        //localStorage.setItem('username', 'xiaobai');
        //查
        //console.log( localStorage.getItem('username') );
------------------------------------------------------9.26------------------------------------------------------------
jquery官网：https://www.jquery.com/（英文）   https://www.jquery123.com/（中文）
<script src="./jquery-3.6.0.js"></script>
//jquery中操作集合，是不需要循环的，省略了循环操作
//$('li').css('background','red');
//$() -> 获取元素，跟css特别类似。
//$().css() : 操作样式，统一了操作，设置还是获取是根据参数决定的,一个参数就是获取，二个参数就是设置
//$('div').css('width','200px');//设置   //console.log( $('div').css('width') );//获取
设置多样式，第一种写法
        $('div')
            .css('width','200px')
            .css('height','300px')
            .css('background','red');
//设置多样式，第二种写法
        /* $('div').css({
            width: '200px',
            height: 300,
            background: 'blue'
        }); */
        // jq中操作css的时候，单位默认是px

//$().attr() : 操作属性,1个参数就是获取，2个参数就是设置
//$().html() : 操作内容,1个参数就是设置，0个参数就是获取
// $().val() : 操作控件的value属性, 1个参数就是设置，0个参数就是获取
        //input.value
        //$('input').val()
$().click() : 操作事件
$().mouseover()
$().mousedown()
$().keydown()
$('div').click(function(){
            //console.log( this );   // 原生的
            //this.innerHTML = 'cccccc';
            //$(this) // JQ的
            $(this).html('ccccc');
        });
		
//链式写法：注意，只有设置操作的时候才具备链式写法，获取操作是没有链式写法的
        $('div')
            .css('border','1px red solid')
            .html('bbbbbb')
            .click(function(){ alert(123) });
            $('div').css('width').html();   //?

        $(function(){/ 等DOM加载完毕，会触发这个函数
            //创建P标签
            var $p = $('<p id="elemP">bbb</p>');
            $('div').append($p);
            
            //length是属性，不是方法，是不加小括号的
            //console.log( $('li').length );  
            //不存在的元素，长度是0，根据是否为0，就能判断这个元素是否获取成功
            console.log( $('h1').length );   // 0
			
//$('div').attr('class','box box2');
//$('div').addClass('box2 box3 box2');//累加class样式，并自动去重
        
//$('div').removeClass('box2');//删除class样式

$('div').toggleClass('box2');//智能切换class：检测是否存在指定的class，存在就删除，不存在就添加
        $('div').click(function(){
            /* if(){
                $().removeClass();
            }
            else{
                $().addClass();
            } */
            $('div').toggleClass('active');
        });
例子		
<button>点击切换</button>
    <div>aaaa</div>
    <script>
        $('div').hide();
        $('button').click(function(){

            $('div').css('display','none');  
            //$('div').show();
            //$('div').toggle();


            // 支持写一个时间参数，可以做动画
            //$('div').toggle(1000);

        });

    </script>

// $('div').css('display','none');
        $('div').hide();
        $('button').on('click',function(){
            $('div').toggle(1000);
        });
		
//针对集合中的第二个元素设置样式
        //$('li').eq(1).css('background','red');
        
        //扩展了一些eq的操作
        //first() === eq(0)
        //$('li').first().css('background','red');
        //last() === eq($('li').length-1)
        //$('li').last().css('background','red');

        //获取集合范围的方法 slice(0,3) 第0个参数起始位置(数组下标为0的)，第3个参数结束位置（不包含结束位置）,即0，1，2位置
        //$('li').eq(1).css('background','red');
        //$('li').eq(2).css('background','red');
        $('li').slice(0,3).css('background','red'); 
        //$('li').slice(1).css('background','red'); 
		
<body>
    <div></div>
    <div></div>
    <div></div>
    <div></div>
    <div></div>
    <script>
        $(function(){
        console.log(123);
    });
    $(function(){
        console.log(456);
    });
    window.onload=function(){
        console.log(789);
    };
    window.onload=function(){
        console.log(10);
    };
    console.log($('div').length);

    //5 10 123 456
    </script>
</body>
------------------------------------------------------9.27Jquery操作节点------------------------------------------------------------
let $nowLi = $('.nowLi');

        // $nowLi.next().css('background','red');//下一个兄弟
        // $nowLi.prev().css('background','blue');//上一个兄弟

        // $nowLi.nextAll().css('background','red');//找下面的所有兄弟节点
        // $nowLi.prevAll().css('background','blue');//找上面的所有兄弟节点

        //找所有的兄弟节点，就是不包含自己
        //$nowLi.siblings().css('background','red');

        //方法的参数是可以进行筛选操作的
        //$nowLi.siblings('li').css('background','red');
        //$nowLi.nextAll('p').css('background','red');
        //$nowLi.next('li').css('background','red');


        //操作子节点
        //children() : 找当前节点的子节点（不包含孙子节点）
        //find() : 找当前节点的所有后代节点

        //$('ul').children('li').css('border','1px red solid');
        //$('ul').find('li').css('border','1px red solid');
    
    
        //操作父节点
        //$('.nowLi').parent().css(); 
        
        //找所有的祖先节点 (找到的是一个集合)
        //$('.nowLi').parents('ul').css(); 
    
        //找满足条件最近的节点 (找到的是一个唯一元素)
        //$('.nowLi').closest('ul').css();
		
		<body>
    <div>divdivdiv</div>
    <span>spanspanspan</span>
    <script>

        //$('div').append( $('span') );//把span剪切到div内容的最后<div>divdivdiv<span>spanspanspan</span></div>
    
        //$('div').prepend( $('span') );

        //$('div').before( $('span') );//<span>spanspanspan</span> <div>divdivdiv</div>
        //$('div').after( $('span') );


        //效果是一样的，区别就在于后续的链式操作
        //$('div').append( $('span') ).css('border','1px red solid');//给div加边框
        //$('span').appendTo( $('div') ).css('border','1px red solid');//给span加边框


        //删除节点
        //$('div').remove();
        //$('span').detach();
        //区别：
            //是否会保留删除元素的行为

       /*  $('div').click(function(){
            alert(123);
        });
        var $div = $('div').remove();   //不会保留

        setTimeout(()=>{
            $('body').append($div);
        }, 3000); */

        /* $('div').click(function(){
            alert(123);
        });
        var $div = $('div').detach();  //会保留

        setTimeout(()=>{
            $('body').append($div);
        }, 3000); */


        //克隆

        $('span').click(function(){
            alert(123);
        });

        var $cloneSpan = $('span').clone(true);  //参数为true，表示克隆节点行为

        $('body').append( $cloneSpan );
    </script>
	
jquery包装方法
<body>

    <span>span</span>
    <span>span</span>
    <p>pppppppppppppp</p>
    <span>span</span>

    <ul>
        <li>aaaa</li>
    </ul>
    <script>

        //包装方法：就是给当前每一个span元素添加父元素div
        //$('span').wrap('<div>');
      
        //整体包装：一旦有其他元素就给其他元素剪切到包装的外面,所有span有一个共同的父元素div
        //$('span').wrapAll('<div>');

        //内部包装：给当前元素的所有子节点如里面的内容 包上一个容器
        $('span').wrapInner('<div>');

        //删除包装：unwrap -> 删除父元素(body是不能删除的)
        //$('li').unwrap();
    </script>
	
/* var $div = $('div');
        $div.css('background','red');
        $div.get(0).innerHTML = 'bbbbb'; */
        //get() : 把JQ转到原生JS
        //有时候，功能用JQ实现不了，就得用原生去实现
        console.log( $('div').get(0).scrollHeight );
		
//$('div').width()  :  元素的尺寸大小
        //console.log( $('div').width() );   // content    
        //console.log( $('div').innerWidth() );   // content + padding
        //console.log( $('div').outerWidth() );   // content + padding + border
        //console.log( $('div').outerWidth(true) );  // content + padding + border + margin
        //JQ跟原生的区别：
            //1. 可以获取到隐藏元素的尺寸大小
            //2. 可以对尺寸进行设置操作
        //$('div').width(400);    // width = 400(content)
        //$('div').innerWidth(400);  // width =  400(content) - padding 
        //$('div').outerWidth(400);  // width =  400(content) - padding - border
        $('div').outerWidth(400, true);  // width =  400(content) - padding - border - margin

JQ遍历
 <ul>
        <li></li>
        <li></li>
        <li></li>
        <li></li>
    </ul>
    <script>
        //遍历
        $('li').each(function(i,elem){
            $(elem).html(i);
        });
		得到结果
		<li>0</li>
        <li>1</li>
        <li>2</li>
        <li>3</li>
    </script>

//可视区的宽
        //console.log( $(window).width() );
        //console.log( $(window).height() );

        //页面的高
        //console.log( $('body').height() );

        //滚动距离
        setInterval(()=>{
            //console.log( $(window).scrollTop() );

            //不仅可以获取，也是可以设置的
            $(window).scrollTop(500);

        }, 1000)
		
//offsetLeft : 原生的会受到定位模式的影响
//console.log( $('.box1').offset().left );  // 当前元素到页面的距离(不受定位模式的影响)
 console.log( $('.box1').position().left );  // 到有定位模式的祖先节点的距离
 
//jquery动画
<button>点击</button>
    <div></div>
    <script>

        //动画：
            //1. 内置的动画 : 9个方法
            //2. 自定义的动画 : animate()

        $('button').click(function(){

            //show()、hide()、toggle() : 动画是相同的，是一组方法。toggle()方法则根据当前状态决定是show()还是hide()
            //$('div').toggle(1000);  // 动画：width height opacity

            //fadeIn()、fadeOut()、fadeToggle() : 动画是相同的，是一组方法。
            //$('div').fadeToggle(1000);  // 动画：opacity

            //slideDown()、slideUp()、slideToggle() : 动画是相同的，是一组方法。
           $('div').slideToggle(1000);   // 动画：height
        });
    </script>
------------------------------------------------------9.28------------------------------------------------------------------------------------------------
$('button').eq(0).click(function(){
            // 第一个参数：样式和目标点
            // 第二个参数：动画的时间，默认值：400ms
            // 第三个参数：动画的形式，swing(缓冲的，默认的，慢快慢)   linear(匀速的)
            // 第四个参数：动画结束的回调
            //$('div').eq(0).animate({ left: 500 }, 2000, 'linear');
            /* $('div').eq(1).animate({ left: 500 }, 2000, 'swing', function(){
                $(this).css('background','blue');
            }); */
            
            /* $('div').eq(1).animate({ left: 500 }, function(){
                $(this).css('background','blue');
            }); */

            //链式动画，这种写法很容器产生回调地狱
            /* $('div').eq(1).animate({ left: 500 }, 2000, function(){
                $(this).animate({ top: 500 }, 2000, function(){
                    $(this).animate({width: 500}, 2000)
                });
            });  */

            //这种写法也支持链式动画
            /* $('div').eq(1)
                .animate({ left: 500 }, 2000)
                .animate({ top: 500 }, 2000)
                .animate({ width: 500 }, 2000);  */

            //delay() : 延迟动画
            /* $('div').eq(1)
                .animate({ left: 500 }, 2000)
                .delay(2000)
                .animate({ top: 500 }, 2000); */
               
            
            //停止动画 : stop()

            $('div').eq(1)
                .animate({ left: 500 }, 2000)
                .animate({ top: 500 }, 2000);
                
        });

        $('button').eq(1).click(function(){

            //$('div').stop();  // 默认：只停止当前动画，不影响后续的链式动画
            
            //$('div').stop(true);  //停止当前动画和后续的所有链式动画
            
            //$('div').stop(true, true);  //第二个参数：可以决定停止到当前动画的目标点
            $('div').finish();   // 停止到所有动画的目标点



        });

//$.fn.extend() 实现自定义插件
//jquery自定义了两个插件名字
	<script>
        $.fn.extend({
            foo: function(options){
                //this -> $('div')
                console.log(options);
            },
            bar: function(){
                console.log('bar');
            }
        });
        $('div').foo({
            username: 'xiaoming'
        });
        $().bar();
    </script>
原生的才有内容的高度scrollHeight

$('button').eq(0).click(function(){
            // 第一个参数：样式和目标点
            // 第二个参数：动画的时间，默认值：400ms
            // 第三个参数：动画的形式，swing(缓冲的，默认的，慢快慢)   linear(匀速的)
            // 第四个参数：动画结束的回调
            //$('div').eq(0).animate({ left: 500 }, 2000, 'linear');
            /* $('div').eq(1).animate({ left: 500 }, 2000, 'swing', function(){
                $(this).css('background','blue');
            }); */
            
            /* $('div').eq(1).animate({ left: 500 }, function(){
                $(this).css('background','blue');
            }); */

            //链式动画，这种写法很容器产生回调地狱
            /* $('div').eq(1).animate({ left: 500 }, 2000, function(){
                $(this).animate({ top: 500 }, 2000, function(){
                    $(this).animate({width: 500}, 2000)
                });
            });  */

            //这种写法也支持链式动画
            /* $('div').eq(1)
                .animate({ left: 500 }, 2000)
                .animate({ top: 500 }, 2000)
                .animate({ width: 500 }, 2000);  */

            //delay() : 延迟动画
            /* $('div').eq(1)
                .animate({ left: 500 }, 2000)
                .delay(2000)
                .animate({ top: 500 }, 2000); */
               
            
            //停止动画 : stop()

            $('div').eq(1)
                .animate({ left: 500 }, 2000)
                .animate({ top: 500 }, 2000);
                
        });

        $('button').eq(1).click(function(){

            //$('div').stop();  // 默认：只停止当前动画，不影响后续的链式动画
            
            //$('div').stop(true);  //停止当前动画和后续的所有链式动画
            
            //$('div').stop(true, true);  //第二个参数：可以决定停止到当前动画的目标点

            $('div').finish();   // 停止到所有动画的目标点



        });
------------------------------------------------------9.29-------------------------------------------------------------
如何做模块化开发？
     1. 形成一个独立的文件，例如：.js文件
     2. 有封闭的环境，对外提供接口，外面才能使用模块
     3. 模块与模块之间可以互相调用
具体模块化如何操作？
            ES6模式：
                1. 需要在一个服务器环境下 , vsCode 去安装 live server 插件。
                    live server跟wamp的区别：就是没有php + mysql环境
                2. 如何在一个模块中引入另外一个模块 , 提供一个对外的接口  
                    export : 会提供多个对外的接口
                    export default : 只会提供一个对外的接口
                3. 如何在一个模块中，引入另外一个模块呢？
                    import xxx from '模块的地址';
                4. 如何把模块添加到页面中呢？
                    那么需要给script标签添加type="module"属性
//ES6模式：
index.html
<script src="./accept.js" type="module"></script>//type="module"模块化文件是异步的。普通js文件是同步的

send.js
//单一接口提供方式
/* var foo=123;
export default foo; */
/* var foo=123;
var err=456;
export default {foo,err};//单一接口写成对象形式可以发送多个值 */

/* // export var foo=123;
// export var bar=456; 
var foo=123;
var bar=456;
export{foo,bar} */
/* //混合写法
var aaaaa=1;
export default aaaaa;
export var bbbbb=2;
export var ccccc=3; */

export function foo(){
    console.log(123);
};
export class Bar{
    constructor(){
        console.log(456);
    }
};
//提供的内容是不能修改的

accept.js
//单一接口接收方式
/* import foo from './send.js';
console.log(foo); */

//单一接口发送多个值
/* import object from './send.js';
console.log(object.foo);
console.log(object.err); */
/* import {foo,bar} from './send.js';
console.log(foo);
console.log(bar); */
/* //混合接口的接收必须先写单一接口，有default的是单一接口
import aaaaa,{bbbbb as b,ccccc} from "./send.js";
console.log(aaaaa);
console.log(b);//as起其别名
console.log(ccccc); */

import {foo,Bar} from './send.js';
foo();
new Bar();

ES5模块:
demo.html
<!-- 引入主模块 -->
<script src="./require.js" data-main="./b.js"></script>
a.js
//requirejs的规范，要先写define()
/* define([], function(){  
    // 这里的代码就是封闭环境,写在外面就不在了
    var foo = 123;
    return foo;  // 提供对外接口(只有这一种写法)
});
 */
/* define([], function(){
    // 这里的代码就是封闭环境
    var foo = 123;
    var bar = 456;
    return {   // 提供多个接口数据出去
        foo,
        bar
    };
});

 */
define([],function(){
    var foo=123;
    var bar=456
    return {foo,bar};
})

b.js
// 引入对应的模块
/* define(['./a.js'], function(foo){
    console.log(foo);
}); */
/* define(['./a.js'], function( obj ){
    console.log(obj.foo);
    console.log(obj.bar);
}); */
/* define(['./a.js'], function( { foo, bar } ){
    console.log(foo);
    console.log(bar);
}); */


// ES6引入多个模块
//import drag from './drag.js';
//import scale from './scale.js';

// ES5引入多个模块
//error
/* define(['./drag.js'], function(drag){
});
define(['./scale.js'], function(scale){
}); */

//success : 一个模块只能有一个define()
/* define(['./drag.js', './scale.js'], function(drag, scale){
}); */

// 引入jquery模块
// 如果提供的接口是采用模块ID的形式，那么引入的接口也要通过模块ID的方式引入
// 引入了对应的模块ID后，默认的模块地址可能跟我们制定的模块地址是不同的
// 要修改默认的模块地址，requirejs.config()
// 配置信息，只在主模块配置就可以，二级模块和三级模块就不需要配置了，直接就可以引入JQ模块。
/* requirejs.config({
    paths: {
        'jquery': './jquery-3.6.0'
    }
});

define(['jquery'], function($){
    console.log($);   // ?
}); */

define(['./a.js','./c.js'],function(obj,{c1,c2}){
    console.log(obj.foo);//123
    console.log(obj.bar);//456
    console.log(c1,c2);//789 10
})
------------------------------------------------------9.30-------------------------------------------------------------
2_node.js
//引入模块
/*var foo = require('./3_node.js');
console.log( foo );*/
/* var obj = require('./3_node.js');
console.log(obj.foo);
console.log(obj.bar); */
/* var {foo, bar} = require('./3_node.js');
console.log(foo);
console.log(bar); */
// 如果要支持ESM写法，需要把js后缀名改成mjs
import foo from './3_node.mjs';
console.log( foo );

3_node.js
/*var foo = 123;
module.exports = foo;*/
/* var foo = 123;
var bar = 456;
module.exports = {
    foo,
    bar
}; */

var foo = 123;
export default foo;

// nodejs : 模块会分为三类 
//     1. 自定义模块
                //支持 CJS 和 ESM 两种写法
//     2. 内置模块
                // 相当于手机里的内置APP
                //querystring : 内置模块，处理字符串的 (过时了)
                //url : 内置模块，处理网址的

//     3. 第三方模块    
                // 相当于手机里的商店中的APP ( 下载 -> npm去下载模块 )
                cmd ->  npm install xxx  (xxx就是模块的名字)
                npm install xxx    : 局部安装 (模块指定在指定目录下使用)
                    momentjs : 处理日期  npm install moment 
                    会自动生成一个 /node_modules的文件夹 : 存放下载所有第三方局部模块
                npm install xxx -g : 全局安装 (模块可以在任意路径下使用)
                    npm i -g nodemon:全局安装nodemon
                    npm root -g : 查看电脑中所有全局模块的安装路径,把这地址复制到高级->环境变量path那
                    nodemon 1_node.js 实时监听代码变化的软件模块,不用每次有变化都在控制台输入node 1_node.js  文件名是1_node.js
                    去文件所在盘那地址输入cmd回车，就会打开控制台

                install 的简写 -> i 
                --global 的简写 -> -g
                规范要求：如果这个模块是在代码中使用的，一般要局部安装；如果这个模块是在命令行中使用的，一般要全局安装
                第三方模块一般分为两类：
                    1. 代码类型的模块 -> 在代码中进行使用 -> 建议：局部安装
                    2. 软件类型的模块 -> 在命令行中进行使用 -> 建议：全局安装
					
在文件所在位置的地址栏按住shift右键打开powerShell  方向键的上箭头执行上一步
执行文件名为node1.js文件，在控制台node node.js
文件名开头几个字母加tab键可以自动补全文件名
clear清除以上记录

//内置模块引入，写模块的名字
const querystring = require('querystring');
var str = 'username=xiaoming&age=20';   
var obj = querystring.parse(str);
console.log( obj );//  { username: 'xiaoming', age: 20 }

npm默认的下载地址在国外npmjs.com，在国内下载速度慢npm.taobao.org
使用第三方模块nrm步骤
1.使用npm install nrm -g 下载它
2.查询可用下载地址列表nrm ls
3.切换npm下载地址nrm use taobao 注：taobao是下载地址名称

------------------------------------------------------10.8-------------------------------------------------------------
手动安装package.json => node init
自动安装node init -y
scripts 定义了一组可以运行的 node 脚本
"scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "node 3_http模块.js",
	"end": "node 3_http模块.js",
	"cow": "cowsay haha"
  },
  命令行输入 npm start相当于node 3_http模块.js
  npm run cow
  简写操作可以省略run有(1)npm start (2)npm restart (3)npm test (4)npm stop
  npm run end
  //scripts 作用2：调用局部的软件类型的包
       //在命令行中调用 cowsay haha  ->  只能调用全局的软件包，不能调用局部的软件包
       //"cow": "cowsay haha"配置好后，输入 npm run cow -> 会调用局部的软件包，如果局部没有这个包的情况下，才会调用全局软件包
  
  
如何把下载的第三方模块的信息写入到这两个字段里呢？
 npm i xxx -S ( -S -> --save ) 安装到  dependencies 这里
  npm i xxx 安装到 dependencies 这里

  npm i xxx -D ( -D -> --save-dev ) 安装到  devDependencies 这里
  //package.json的应用：把文件发送给对方，并且不发送node_modules文件夹，对方会自己根据package.json中的信息进行全部安装，通过 npm i 这条命令

            // 了解一下版本号：
            //     "moment": "2.29.1" -> 安装2.29.1这个版本，当版本有更新的时候也不会安装新的版本，就会安装这个指定的版本

            //     "moment": "^2.29.1"  -> 当版本有更新的时候，大版本是固定的，而中版本会选择最新的

            //     "moment": "~2.29.1" ->  当版本有更新的时候， 大版本和中版本都会固定，而只会更新补丁版本

            //     "moment": "latest"  -> 安装最新版本

            //     "moment": "^2.29.1" 如何有锁定文件的存在 package-lock.json 会根据锁定文件中指定的版本进行安装，并不会自动更新
            
// 卸载npm模块：
    // npm uninstall xxx (局部卸载)
    // npm uninstall xxx -g (全局卸载)

// npm i (npm install) : 根据package.json中的所有 dependencies、devDependencies信息进行所有对应模块的安装
   //npm i --production : 根据  dependencies 进行安装
   //npm i --only=dev :   根据 devDependencies 进行安装
//npm view xxx versions : 查看当前xxx模块的所有版本
//npm i xxx@1.2.3 : 安装xxx的1.2.3的版本
//npm outdated : 查看当前项目下有哪些模块已经过时了，跟最新版本是不一样的
//npm update xxx : 更新xxx模块，根据package.json中指定的信息进行更新
------------------------------------------------------10.9-------------------------------------------------------------
http模块
let http = require('http');     // 非安全协议，不会对传输的数据进行加密
let https = require('https');  // 安全协议，会对传输的数据进行加密处理( 想拥有https协议，需要去申请，通过CA认证 )
//cheerio : 模拟jquery功能，但是是在服务端使用的
let cheerio = require('cheerio');
//要请求的地址是https的地址，那么就要选择使用https模块
/* https.get('https://www.lagou.com/', (res)=>{

    //res : 响应对象

    var content = '';

    res.on('data', function(chunk){//等以上get请求完内容累加完后执行里面内容
        //chunk : 爬取到另外服务器后端的资源数据，分批次爬取的，所以这个回调会触发很多次
        //console.log(chunk);
        content += chunk;
    });
    //等数据全部接收完毕后触发
    res.on('end', function(){
        //console.log(content);
        let $ = cheerio.load(content);
        let json = {
            "code": 0,
            "errmsg": "ok",
            "list": []
        };
        $('.menu_box h2').each((i, elem)=>{
            //console.log( $(elem).html().trim() );
            json.list.push({"title": $(elem).html().trim()});
        });

        console.log( json );

    });


});




let https=require('https');
let http=require('http');
let cheerio=require('cheerio');
//创建web服务器
let server=http.createServer((req,res)=>{
//req(request)请求对象
//res(response)响应对象
    /* console.log(req.url);///index.html /favicon.ico 不包含域名
    console.log(req.method);//GET
    console.log(req.headers.host);//域名localhost:3000 */

    //http://localhost:3000/index.html?username=xiaoming&age=10
    //console.log(new URL(req.headers.host+req.url).searchParams.get('username'));//xiaoming

    //拿post发送过来的数据
    let content='';
    req.on('data',(chunk)=>{
        content+=chunk+'';
    });
    req.on('end',()=>{
       // console.log(new URLSearchParams(content));//text（/plain 名称/值）对
       console.log(JSON.parse(content).age);//json
    })

	/* res.write('hello');
    res.end(); */
    res.end('hello');
});
//开启web服务器http://localhost:3000/index.html
server.listen(3000,'localhost',(err)=>{
    if(!err){
        console.log('web服务器启动成功');
    }else{
        console.log('web服务器启动失败');
    }
});//（端口，域名，回调监听web服务器启动是否成功）

------------------------------------------------------10.11-------------------------------------------------------------
CSS预处理：一开始写的代码并不是CSS代码( 更加高级的语法：变量、语句、函数、继承等等 )，这些非CSS代码浏览器不认识，然后通过一些手段转成我们认识的CSS代码，这样浏览器就认识了。
        浏览器预览效果的时候：真正的CSS代码 ( 需要把CSS预处理代码 -> CSS代码 )
        1. 如何写CSS预处理代码： 方案非常多：ass(学习！)、less、stylus .....
        2. 如何把CSS预处理转成普通CSS：方案非常多：
            通过webpack工具、gulp工具
            vsCoode插件：下载easy sass  ->  xxx.sass (编写代码) -> xxx.css (浏览效果) 
            xxx.sass 文件 对代码的编写非常严格，类似于python的语法格式。
            xxx.scss 文件 也是sass一种文件格式，比sass格式要简单，类似于CSS语法格式。
            xxx.scss 文件的好处：
                1. 可以直接写普通的CSS代码
                2. 也可以写sass提供的语法
                通过使用scss文件：基本上就是在原有的css基础上扩展了一些功能
        CSS后处理：了解一下 postcss 
		
注释：  // 不会被编译   /* */  会被编译
变量：$number : 123; 
插值：#{$key}
demo1.scss
body{
    background: red;
    width: 200px;
}
// $number: 100;
// $color: red;

// .box{
//     width: $number;
//     height: $number;
//     background: $color;
// }
// .box2{
//     margin: $number;
//     color: $color;
// }

//插值 #{}
//变量默认只能作为值，但是如何能让变量成为选择器或属性呢？可以利用插值
// $number: 100;
// $color: red;
// $i : 4;
// $attr: margin;

// .box{
//     width: #{$number}px;
// }

// .box#{$i}{
//     width: $i;
//     #{$attr}: 100px;
// }

//支持运算
// $number: 100;
// $color: #123456;

// .box{
//     width: #{$number / 2}px;
//     width: #{$number} / 2;
//     width: $number * 2;
//     width: $number + 2;
//     width: $number - 2;
//     width: $number % 2;
//     color: $color * 3;
//     color: $color * 4;
//     color: $color * 5;
// }
//作用域
// $number: 200;
// .box{   
//     width: $number;  // 200
//     $number: 100;
//     height: $number; // 100
// }


//嵌套
// ul li{ list-style: none; }
// ul li div{ width: 100px; height: 100px;}
// ul li div span{ color: red;}

// ul{
//     li{
//         list-style: none;
//         div{
//             width: 100px; height: 100px;
//             span{
//                 color: red;
//             }
//         }
//         p{
//             text-align: center;
//         }
//     }
// }

// ul:hover{
//     background:red;
// }

// &会忽略空格
// ul{
//     &:hover{
//         background:red;
//     }
// }


// .qf-main{}
// .qf-main-title{}
// .qf-main-title-logo{}
// .qf-main-title-head{}
// .qf-main-title-foot{}
// .qf-main-content{}
// .qf-main-content-list{}
// .qf-main-content-item{}
// .qf-main-content-icon{}

// .qf-main{
//     width: 1px;
//     &-title{
//         width: 1px;
//         &-logo{width: 1px;}
//         &-head{width: 1px;}
//         &-foot{width: 1px;}
//     }
//     &-content{
//         width: 1px;
//         &-list{width: 1px;}
//         &-item{width: 1px;}
//         &-icon{width: 1px;}
//     }
// }

// .box{
//     font-size: 20px;
//     font-weight: blod;
//     font-style: italic;
//     width: 100px;
// }

.box{
    font: {
        size: 20px;
        weight: blod;
        style: italic;
    }
    width: 100px;
}

demo1.html
<style>
:root{
            --color: blue;
        }
        div{
            background: var(--color);
        }
        li{
            background: var(--color);
        }
</style>
<script>
        setTimeout(()=>{
            document.documentElement.style.setProperty('--color', 'red');
        }, 1000);
    </script>		
------------------------
//混入
// .box1{
//     width: 100px;
//     height: 200px;
//     position: absolute;
//     left:0;
//     top:0;
// }
// .box2{
//     width: 200px;
//     height: 300px;
//     position: absolute;
//     left:0;
//     top:0;
// }

//混入：就是抽离公共的样式
// @mixin dir {
//     position: absolute;
//     left:0;
//     top:0;
// }
// .box1{
//     width: 100px;
//     height: 200px;
//     @include dir;
// }
// .box2{
//     width: 200px;
//     height: 300px;
//     @include dir;
// }

// 可以添加默认值
// @mixin bg ($color:blue){
//     background: $color;
// }
// .box1{
//     @include bg(red);
// }
// .box2{
//     @include bg(yellow);
// }
// .box3{
//     @include bg();
// }

//继承：跟混入很像
// %color {
//     background: red;
// }
// .box1{
//     @extend %color;
// }
// .box2{
//     @extend %color;
// }

// @mixin bg {
//    background: yellow;
// }
// .box3{
//     @include bg;
// }
// .box4{
//     @include bg;
// }

一个方块当分比率大于800的时候颜色红色，400到800之间是黄色，小于400颜色蓝色

min-width : 先布局移动端，响应式适配PC端(从小到大)
//手机端
.box{
    background: blue;
}

//iPAD端
@media screen and (min-width: 400px) {
    .box{
        background: yellow;
    }
}
//PC端
@media screen and (min-width: 800px) {
    .box{
        background: red;
    }
}

max-width : 先布局PC端，响应式适配移动端 
// PC端
.box{
    background: red;
}

// iPAD端
@media screen and (max-width: 800px) {
    .box{
        background: yellow;
    }
}
//手机端
@media screen and (max-width: 400px) {
    .box{
        background: blue;
    }
}


sass是可以这样写的
.box{
    background: red;
    @media screen and (max-width: 800px) {
        background: yellow;        
    }
    @media screen and (max-width: 400px) {
        background: blue;
    }
}
------------------------
//混入
.box1{
    width: 100px;
    height: 200px;
    position: absolute;
    left:0;
    top:0;
}
.box2{
    width: 200px;
    height: 300px;
    position: absolute;
    left:0;
    top:0;
}

//混入：就是抽离公共的样式
@mixin dir {
    position: absolute;
    left:0;
    top:0;
}

.box1{
    width: 100px;
    height: 200px;
    @include dir;
}
.box2{
    width: 200px;
    height: 300px;
    @include dir;
}

//可以添加默认值
@mixin bg ($color:blue){
    background: $color;
}

.box1{
    @include bg(red);
}
.box2{
    @include bg(yellow);
}
.box3{
    @include bg();
}

//继承：跟混入很像

%color {
    background: red;
}
.box1{
    @extend %color;
}
.box2{
    @extend %color;
}


@mixin bg {
   background: yellow;
}
.box3{
    @include bg;
}
.box4{
    @include bg;
}
---------------------------------------------------------------------------10.12------------------------------------------------------------------------------
官网 https://gulpjs.com/
1.安装Gulp工具：
	npm install --global gulp-cli
2.在项目目录下创建 package.json 文件 
	npm init -y
3.安装 gulp，作为开发时依赖项
	npm install --save-dev gulp     
4.创建Gulp任务：
	创建 gulpfile.js 文件
	创建任务（task）


let { series, parallel, src, dest } = require('gulp');
let sass = require('gulp-sass')(require('sass'));
let autoprefixer = require('gulp-autoprefixer');
let cssmin = require('gulp-cssmin');//安装 npm i -D gulp-cssmin //D只在开发时用

//第一个任务
function oneTask(cb){
    console.log(123);
    cb();  // 结束异步函数调用
}

//第二个任务
function twoTask(){
    console.log(456);
    return Promise.resolve();   // 结束异步函数调用
}

//拷贝文件的任务 src读取 pipe连接 dest写入
function copyTask(){
   /* return src('./src/a.txt')
            .pipe( dest('./dist') )  //如何没有dist文件夹，会自动创建 */    
    /* return src(['./src/a.txt', './src/b.txt', './src/c.txt'])
            .pipe( dest('./dist') ) */
   /* return src('./src/*.txt')
            .pipe( dest('./dist') ) */
  /*  return src('./src/*.**')   // src下所有的文件
            .pipe( dest('./dist') ) */
  return src('./src/**')   // src下所有
            .pipe( dest('./dist') )
}

// sass文件转换的任务
function sassTask(){
    return src('./src/*.scss')//读文件
            .pipe(sass())   // 调用sass函数，完成文件的转换
            .pipe( dest('./dist') )//写入文件
}

// 添加浏览器前缀的任务
function autoTask(){
    return src('./src/*.css')
            .pipe(autoprefixer())//添加浏览器前缀
            .pipe(cssmin())//压缩
            .pipe( dest('./dist') )
}
//往package.json添加
/* "browserslist": [
    "last 1 version",
    "> 1%",//市场份额
    "maintained node versions",
    "not dead"
  ]　　*/


//提供对外的接口(使用多接口的写法)
module.exports = {
    oneTask,//oneTask:oneTask,
    twoTask,
    sTask: series(oneTask, twoTask),//按顺序执行任务
    pTask: parallel(oneTask, twoTask),//同时执行任务
    copyTask,
    sassTask,
    autoTask,
};
// npm oneTask/npm twoTask...

let fileInclude = require('gulp-file-include');
//把HTML做成模板片段
function fileIncludeTask(){
    return src('./src/*.html')
            .pipe( fileInclude({
                prefix: '@',      // 使用模板的时候采用的前缀符号
                basepath: './src/include'   //模板的根目录
            }) )
            .pipe( dest('./dist') );
}
//提供对外接口
module.exports={
    fileIncludeTask
};

//src/index.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    @include('header.html',{
        username:'xiaoming',
        isGoodsList:false
    })
    <h2>我是首页</h2>
    @include('foot.html')
</body>
</html>


//src/detail.html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    @include('header.html',{
        isGoodsList:true
    })
    <h2>我是商品页</h2>
    @include('foot.html')
</body>
</html>


//src/include/header.html
<h1>这是头部</h1>
<ul>
    @if(isGoodsList){
        <li>商品详情页</li>
    }
    <li>首页</li>
    <li>我的</li>
    <li>@username</li>
    
</ul>

//src/include/foot.html
<table border="1">
    <tr>
        <th>1</th>
        <th>2</th>
        <th>3</th>
        <th>4</th>
    </tr>
</table>
-------------------------------------------------------------10.13--------------------------------------------------------------------------------
 git reset --hard HEAD 撤销之前的操作
 git工具的使用：
    1. 下载安装：https://git-scm.com/，鼠标右键查看是否安装成功
    2. 两种模式：GUI模式(可视化界面：软件的使用)、Bash模式(命令行操作：写代码)
    3. 如何利用Bash模式，进行git开发：
        在指定的目录下打开git工具，这样就只会管理指定路径下的文件
-------------------------------------------------------------

    1. 初始化git工具：git init

    2. 设置git工具的用户名和邮箱（设置一次即可，以后此电脑再使用git的时候就可以不用设置了）

        git config --list : 查看配置信息

            必须有 user.name 和 user.email 的配置

        git config --global user.name “xxx”  :  添加配置
        git config --global --unset user.name  : 删除配置

    3. 版本管理的是文件的状态(快照)：添加、修改、删除等等（任何操作都是快照）

        查看状态： git status

            1. 如果看到"红色"，说明工作区和暂存区状态不同

            2. git add a.txt : 
			

            3. 如果看到"绿色"，说明暂存区和版本区状态不同

            4. git commit -m "添加了a.txt文件" : 把暂存区中的状态同步到版本区，并且生成一个版本（版本的注释内容为：添加了a.txt文件）

            5. git add .  : 把工作区所有要同步的文件状态，同步到暂存区

            6. git log : 查看所有版本信息

                commit 48605df0fed41ca978167e81a1ca5156bdd6eb19 : commitId(版本的唯一标识)

                git log --pretty=oneline : 一行显示信息

            7. master(主分支)：默认下只有一个主分支，用来存储对应的版本的

                HEAD(指针)：指针指向哪里就说明当前是哪个版本


            8. 删除文件：
                1. 工作区手动删除 ,  git add .   git commit 完成删除的同步
                2. git rm c.txt : 删除工作区中的c.txt，并且同步状态到暂存区

            9. --amend : 在提交的时候，可以直接使用已有的版本，不产生新的版本

                git commit --amend -m "xxx" : 利用已有版本进行合并，不产生新版本

            10. git diff : 工作区和暂存区差异对比

                git diff --cached : 暂存区和版本区对比

                git diff master : 工作区和版本区对比

            11. 回退版本：回到过去

                git reset --hard HEAD : 回到指针的当前版本

                    把工作区和暂存区的状态还原回，当前指针对应的版本

                git reset --hard HEAD^ : 当前指针的前一个版本
                git reset --hard HEAD^^ : 当前指针的前两个版本
                git reset --hard HEAD~50 : 当前指针的前50个版本

                git reset --hard commitId : 回到指定commitid的版本(回到过去，也可以回到现在)

            12. git reflog : 查看历史记录

            13. 撤销(检出)：让代码回到之前版本的样子，但是不进行版本的回退

                git checkout commitId xxxx : 把指定版本的xxxx状态同步到工作区和暂存区
                git checkout -- xxxx : 把暂存区的xxxx状态同步到工作区


// github网站和多人协作：

    1. github账号，并且登录

    2. 电脑跟网站通信：HTTPS 、SSH（如何配置）
       在管理员账号下找到.ssh文件夹，如果没有就去生成：
            ssh-keygen -t rsa -C "你的邮箱@qq.com"

         把公钥在github网站设置一下，这样就可以电脑跟github通信了
		右上角Settings=> SSH and GPG keys=>New SSH key=>把.ssh文件里的id_rsa.pub文件内容往Key框里粘贴，Title款内容随便
		右上角+里New reponsitory创建仓库

    3. 创建一个远程仓库：存储准备要上传的分支（指定的一些版本）

        .gitignore的文件：里面内容设置git不想管理的文件夹和文件

        生成一个仓库的地址：git@github.com:账号名/仓库名.git

    4. 设置远程地址：remote ，可以指定跟远程的哪一个仓库进行通信

        git remote : 查看远程地址
                        远程地址起一个名字 远程地址的SSH的路径
        git remote add origin git@github.com:qyy0125/gitstudy2.git

    5. 把本地master分支push上传到对应的远程地址上
                远程地址的名字  本地分支的名字
        git push origin master : 上传版本到指定的github上

    //-----------------------------------------------------

    6. 如何去pull下载github上的版本到电脑？

        git clone 仓库的地址

    7. 需要设置成协作者Manage access，才能有上传的权限


    8. 拉取（下载）最新的代码：

        git pull origin master 远程地址名 主分支


    9. 冲突的情况：

        远程仓库的版本 跟 本地开发的版本 有冲突了，这样就不能push上去了
        需要pull下代码，然后手动抉择使用什么样的代码作为最新的上传代码，并push上去。


git 分支：

    master主分支（默认带的）
    分支可以实现更多的需求。
    git branch : 查看当前有多少个分支
    git branch new : 创建一个new分支
    git checkout new : 切换到new分支上 
    git merge new : 合并new分支
    git branch -d new : 删除new分支
    git push origin new : 把new分支上传到github上

git tag : 生成里程碑
    git tag : 查看里程碑
    git tag v1.0.0 : 创建一个叫做v1.0.0的里程碑

--------------------------------------------------------------------------10.18项目--------------------------------------------------------
(1)创建src文件夹:
lib第三方资源如require.js jquery.
static静态资源img icon
view{templates文件夹存放公共的HTML代码(head.html,foot.html,banner.html)，index.html,detail.html,cart.html}
css存放sass文件{modules文件夹存放公共的HTML代码(head.scss,foot.scss,banner.scss),index.scss,detail.scss,cart.scss}
api接受后端数据(server.js)
(2)dist文件夹 存放src转换成浏览器所识别的代码:
(3)创建package.json在当前文件打开cmd回车
npm init -y
(4)gulpfile.js
在当前文件打开cmd回车
npm i -D gulp gulp-file-include gulp-clean gulp-webserver gulp-sass sass

如果拷贝别的package.json文件，直接npm i 安装里面所需要的
(5).gitignore存放不想管理的文件node_modules
(6)运行第三方库
 =>package.json写入"dev":"gulp dev"
cmd =>npm run dev
(7)初始化git工具：git init
出来.git文件夹
注意。只要gulpfile.js文件一旦改变就需要重启npm run dev


1.文件夹moudules(common.scss,head.scss,foot.scss)
index.scss引入公共模块@import './modules/common.scss';
					  @import './modules/head.scss';
					  @import './modules/foot.scss';
					  
2.文件夹moudules(head.html,foot.html)
index.html引入公共模块@include('./modules/head.scss')
					@include('./modules/foot.scss')
head.html,foot.html公共模块不用写<!DOCTYPE html>
								<html lang="en">
								<head>
									......
								</head>
								<body>
					  
--------------------------------------------------------------------------------------------------------------------------------------------------------------
参数name 描述:
选中复选框为true，没选中为false

jQuery 代码:
$("input[type='checkbox']").prop("checked");
参数properties 描述:
禁用页面上的所有复选框。

jQuery 代码:
$("input[type='checkbox']").prop({
  disabled: true
});
参数key,value 描述:
禁用和选中所有页面上的复选框。

jQuery 代码:
$("input[type='checkbox']").prop("disabled", false);
$("input[type='checkbox']").prop("checked", true);
参数key,回调函数 描述:
通过函数来设置所有页面上的复选框被选中。

jQuery 代码:
$("input[type='checkbox']").prop("checked", function( i, val ) {
  return !val;
});

<body>
    <!-- <input type="checkbox" checked>
    <input type="checkbox" checked>
    <input type="checkbox" checked>
    <input type="checkbox" checked> -->
    <input type="checkbox" class="box1">
    <input type="checkbox">
    <input type="checkbox">
    <input type="checkbox">
    <script>
        /* $("input[type='checkbox']").prop({
            disabled: true
        }); */
        // $("input[type='checkbox']").prop("disabled", true);//全部禁用，为false是都不禁用
        // $("input[type='checkbox']").prop("checked", true);//全选
        // $("input[type='checkbox']").prop("checked", false);//取消全选
        /* $("input[type='checkbox']").prop("checked", function (i, val) {
            return !val;
        });//全选 */
        $('.box1').on('click',function(){
            let isChecked = this.checked;
            console.log(isChecked);//当第一次点击true
        })

    </script>
</body>


attr
参数name 描述:
返回文档中所有图像的src属性值。

jQuery 代码:
$("img").attr("src");
参数properties 描述:
为所有图像设置src和alt属性。

jQuery 代码:
$("img").attr({ src: "test.jpg", alt: "Test Image" });
参数key,value 描述:
为所有图像设置src属性。

jQuery 代码:
$("img").attr("src","test.jpg");
参数key,回调函数 描述:
把src属性的值设置为title属性的值。

jQuery 代码:
$("img").attr("title", function() { return this.src });

