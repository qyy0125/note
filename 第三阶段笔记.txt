--------------------------------------------10.25第三阶段---------
1. http://www.young1024.com:3008/
2.vue开发文档 https://cn.vuejs.org/
3.克隆上课代码
$ git clone https://gitee.com/youngzl/dl2104.git

vue使用v-model实现这些标签数据的双向绑定，输入框的内容和div里的内容同步
<div id="app">
	{{msg}}

	<input type="text" v-model="msg">
</div>
<script type="text/javascript">
	var app = new Vue({
		el:'#app',
		data:{
			msg:'hello vue'
		}
	})
</script>

<body>
    <div id="box">
        {{msg}}
    </div>
    <!-- 引入vue的库文件 -->
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
    <script>
        new Vue({
            el:'#box',
            data:{
                msg:'hello vue'
            }
        })
    </script>
	
<div id="app-3">
        <p v-if="seen">现在你看到我了</p>
        {{msg}}
      </div>
    <!-- 引入vue的库文件 -->
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
    <script>
        var app3=new Vue({
            el:'#app-3',
            data:{
                seen: true,
                msg:'hello'
            }
        })
        //控制台输入app3.seen = false,字就会消失
		
Object.defineProperty(obj, prop, descriptor)
obj要定义属性的对象。
prop要定义或修改的属性的名称或 Symbol 。
descriptor要定义或修改的属性描述符。

插值表达式
v-html成功的解析了标签属性
v-text指令被直接解析为了字符串元素
---
<style>
        [v-cloak]{
            display: none;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
</head>
<body>
    <!-- 可以使用 v-cloak 指令设置样式，这些样式会在 Vue 实例编译结束时，从绑定的 HTML 元素上被移除。
    当网络较慢，网页还在加载 Vue.js ，而导致 Vue 来不及渲染，这时页面就会显示出 Vue 源代码。-->
    <div id="box" v-cloak>
        <input type="radio" name="sex" value="0" v-model='sex'>男
        <input type="radio" name="sex" value="1" v-model='sex'>女
        {{sex}}

        <select value="3" v-model="sel">
            <option value="3">等待</option>
            <option value="4">方法</option>
            <option value="5">公共</option>
        </select>
        {{sel}}
    </div>
    <script>
        setTimeout(()=>{
            var box = new Vue({
            el: '#box',
            data: {
                sex:1,
                sel:4
            }

        })
        },2000);  
    </script>
---
v-model用于表单数据的双向绑定，其实它就是一个语法糖，这个背后就做了两个操作：
1. v-bind绑定一个value属性
2. v-on指令给当前元素绑定input事件

--- v-once 只会渲染一次，后续更新的数据不会再渲染 ---
	<div v-once>{{msg}}</div>
	
    <div id="app">
        <button v-on:click="say(1,$event)">{{msg}}</button><!-- 如果不传参直接写say,不用加括号 -->
        {{num}}
    </div>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
    <script>
        new Vue({
            el:'#app',
            data:{
                msg:'hello',
                num:0
            },
            methods:{//一定不要漏了s
                say(n,e){/* 如果前面say没传参数,say(e)里的e默认是事件对象 */
                    console.log(n,e);
                    this.num=n;//this代表当前实例
                    console.log(123);//看事件是否触发
                    console.log(this.msg);//'hello'
                }
            }
        })
    </script>
---v-bind用于绑定属性和数据---
v-bind:href="xxx"等于 :href="xxx"
<div id="app">
        <img v-bind:src="imgsrc" :alt="alt" v-bind:title="title">
    </div>
    <script>
        new Vue({
		el:'#app',
		data:{
			imgsrc:'https://img.alicdn.com/bao/uploaded/i4/50454948/O1CN01kPsXyC1mQERGyxSbN_!!50454948.jpg_400x400.jpg',
			title:'这是一件衣服',
			alt:'这就是一件衣服'
		}
	})
    </script>
	
<div id="app">
        <p :style="{fontSize:size+'px'}">hello</p>
        <button @click="run">点击</button>
    </div>
    <script src="../node_modules/vue/dist/vue.js"></script>
    <script>
        new Vue({
            el:'#app',
            data:{
                size:17
            },
            methods:{
                run(){
                    this.size++
                }
            }
        })
    </script>
---
v-on:click="xxx"等于@click="xxx"
---阻止事件冒泡，阻止默认事件---
<div id="app"> 
       <div class="red" v-on:click.stop='red'>
           <div class="blue" @click.stop='blue'><!-- stop阻止事件冒泡 -->
            <a v-bind:href="href" v-on:click.prevent.stop='say'>百度</a><!-- prevent阻止默认事件a链接的跳转 -->
           </div>
       </div>
    </div>
    <script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
    <script>
        new Vue({
            el:'#app',
            data:{
                msg:'hello',
                num:0,
                href:'http://news.baidu.com/'
            },
            methods:{
                say(){/* 如果前面say没传参数,say(e)里的e默认是事件对象 */
                    console.log(123);
                },
                blue(){
                    console.log(456);
                },
                red(){
                    console.log(789);
                }
            }
        })
    </script>
	
-------
@keyup(键盘事件)是按键松开，当指定的按键松开会触发的事件

事件代码	事件描述
@keyup.enter	回车按键松开
@keyup.left	左键按键松开
@keyup.right	右键按键松开
@keyup.up	上键按键松开
@keyup.down	下键按键松开
@keyup.delete	删除键松开
------------------------------------------10.26--------------------------------------
<style type="text/css">
		.active{
			font-size: 50px;
		}
		.color{
			color: red;
		}
	</style>
<!-- 对象写法：  key 需要显示的样式， value决定它要不要显示的变量   -->  class
	<div :class="{active:isActive,color:color}">这是测试文字</div>
	<!-- 数组写法：  数组的每一项 都会找对应的value：value是我们要显示的样式  -->
	<div :class="[cl]">这是测试文字222</div>
	data:{
			isActive:true,
			color:true,

			arr:'active',
			c1:'color'
		}
		
行内样式style	
<div id="app" :style="[cc,dd]"></div>
data:{
              cc:{color:'red'},
              dd:{fontSize:'30px'}
            }
			
v-model修饰符
<div id="app">
	<!-- lazy失去焦点 焦点离开输入框才去改变数据 -->
	<input type="text" v-model.lazy="msg">
	{{msg}}

	<hr>
	<!-- 转换为数字 输入框12px,输入框外12 -->
	<input type="text" v-model.number="num">
	{{num}}


	<hr>
	<!-- 去除空格，只有第一次按下空格才有空格 -->
	<input type="text" v-model.trim="massage">
	{{massage}}

</div>	

自定义指令
当页面加载时，该元素将获得焦点
// 注册一个全局自定义指令 `v-focus`
Vue.directive('focus', {
  // 当被绑定的元素插入到 DOM 中时……
  inserted: function (el) {
    // 聚焦元素
    el.focus()
  }
})
如果想注册局部指令，组件中也接受一个 directives 的选项：
directives: {
  focus: {
    // 指令的定义
    inserted: function (el) {
      el.focus()
    }
  }
}
然后你可以在模板中任何元素上使用新的 v-focus property，如下：
<input v-focus>

el：指令所绑定的元素，可以用来直接操作 DOM




<div id="app">
	
	<input type="text" v-focus>

	<div v-color="'blue'">测试文字</div>

	<div v-size="66">测试文字</div>

	<div>
		<input type="text" v-phone v-model="phone">
	</div>

</div>
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
<script>
	//自定义全局指令
	// 参数1： 指令名称  不需要带v- ，在使用的时候才需要
	// 参数2： 配置钩子函数的对象 
		// 回调函数中 常用的 参数
		// el el是当前绑定的元素对象
		// //binding和属性相关的对象
	Vue.directive('focus',{
		bind:function(){  // 第一次绑定的时候调用
			// 通常是做一些初始化的操作
		},
		inserted:function(el,binding){
			// console.log(el)  // el是当前绑定的元素对象
			// console.log(binding)  //binding和属性相关的对象
			el.focus()
		},
		update:function(){ //绑定的元素更新的时候的调用

		}
	})

	Vue.directive('color',{
		inserted:function(el,binding){
			// console.log(binding.value) //获取传进来的值
			// console.log(binding.expression) //获取到传进来的表达式
			 //console.log(binding)
			el.style.color = binding.value
		}
	})

	new Vue({
		el:'#app',
		data:{
			phone:''
		},
		directives:{  //定义局部指令 key:为指令名，value就是钩子函数的配置对象
			size:{
				inserted:function(el,binding){
					el.style.fontSize = binding.value+'px'
				}
			},
			// phone:{
			// 	inserted:function(el){
			// 		console.log(el.value)
			// 	},
			// 	update:function(el){
			// 		console.log(el.value)
			// 	}
			// }

			phone:function(el){ //简写方式：bind和update是一样的函数，就可以使用简写
				// console.log(el.value)

				if(/^(?:(?:\+|00)86)?1(?:(?:3[\d])|(?:4[5-79])|(?:5[0-35-9])|(?:6[5-7])|(?:7[0-8])|(?:8[\d])|(?:9[189]))\d{8}$/.test(el.value)){

					el.style.color = 'green'
				}else{
					el.style.color = 'red'
				}
			}
		}
	})
</script>


<div id="app">
	<ul>
		<!-- :key 是一个唯一的值  -->
		<li v-for="(item,index) in list" :key="index">{{index}}--{{item}}</li>
	</ul>

	<ul>
		<!-- 
			如果是index , 在中间插入一条后面的元素都会重新渲染
			如果是一个唯一值（ID）, 就不会重新渲染了

			如果没有唯一值，可以用index代替
		 -->
		<li v-for="(item,index) in list" :key="item">{{item}}</li>
	</ul>

	<button @click="add">add</button>
	<button @click="addend">addend</button>

	<ul>
		<li v-for="item in 10">{{item}}</li>
	</ul>
	<hr>
	<ul>
		<!--  遍历一个对象 

		参数1：value值
		参数2：key名称
		参数3：序号
		 -->
		<li v-for="(value,key,index) in person">{{index}}--{{key}}:{{value}}</li>
	</ul>



</div>

<script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
<script type="text/javascript">
	
	new Vue({
		el:'#app',
		data:{
			list:['a','b','c','d','e'],
			person:{
				name:'young',
				age:18,
				sex:1,
				city:'大连'
			}
		},
		methods:{
			add(){
				// this.list.push('f')
				this.list.splice(1,0,'f')
			},
			addend(){
				this.list.push('z')
			}
		}
	})
</script>

----------------------------------------------------------10.27---------------------
<input type="text" v-model="firstname">
		<input type="text" v-model="lastname">
		<input type="text" v-model="fullname">
//computed
data:{
			msg:'hahha',
			firstname:'',
			lastname:'',
			// fullname:'' // 重复定义就会报错
		},
		computed:{
			fullname(){
				return this.firstname+this.lastname;
			}
		}
		
<input type="text" v-model="person.firstname">
		<input type="text" v-model="person.lastname">
		<input type="text" v-model="person.fullname">		
//watch深度监听
data:{
			msg:'hahha',
			person:{
				firstname:'young',
				lastname:'zlin',
				fullname:'youngzlin'
			}
		},
		watch:{
			// person(){  
				//如果person 中firstname/lastname/fullname 发生改变都不触发这个监听器 因为这是一个对象
			// 	console.log('aaaa')
			// }

			person:{
				handler:function(newval,oldval){ //监听对象是拿不到之前的值的
					// console.log('aaaa')
					console.log(newval)
					this.person.fullname = newval.firstname+newval.lastname
				},
				deep:true, // 只要加上这个属性才会被深度监听
				immediate: true // 主动触发一次侦听函数
			}
		}		
--生命周期--
<div id="app">
	{{msg}}
	<input type="text" v-model="msg">
	<button @click="des">销毁实例</button>
</div>
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
<script type="text/javascript">
	var app=new Vue({
		el: '#app',
		data:{
			msg:'hello'
		},
		methods:{
			des(){
				this.$destroy()  // 手工销毁实例
			}
		},
		beforeCreate(){
			
			/* console.log('创建前');
			console.log(this.msg)  // data还未创建好
			console.log(this.$el)  // 实例未挂载
			console.log(document.getElementById('app').innerHTML) // 模板未编译
			console.log(document.getElementById('app')) */
		},
		created(){
			/* 
			console.log('创建后');
			console.log(this.msg)  // data已经创建好
			console.log(this.$el)   // 实例未挂载
			console.log(document.getElementById('app').innerHTML) // 模板未编译
			*/
		},
		beforeMount(){
			/*
			console.log('挂载前');
			console.log(this.msg)  // data已经创建好
			console.log(this.$el)  // 实例已挂载 
			console.log(document.getElementById('app').innerHTML)  // 模板未编译
			*/
		},
		mounted(){
			/*
			console.log('挂载后------');
			console.log(this.msg)  // data已经创建好
			console.log(this.$el)  // 实例已挂载，并且已编译 
			console.log(document.getElementById('app').innerHTML)  //模板已编译
			*/
		},
		beforeUpdate(){
			/*
			console.log('更新前')
			console.log(this.msg)  //data已变化
			console.log(this.$el)  //实例也已经更新
			console.log(document.getElementById('app').innerHTML) 
			//还没有更新模板
			*/
		},
		updated(){
			/*
			console.log('更新后');
			console.log(this.msg)  //data已变化
			console.log(this.$el)  //实例也已经更新
			console.log(document.getElementById('app').innerHTML) 
			//已经更新模板
			*/
		},
		beforeDestroy(){
			/* console.log('销毁前'); // 销毁前还是好的实例
			console.log(this.msg) 
			console.log(this.$el)  
			console.log(document.getElementById('app').innerHTML)  */
		},
		destroyed(){
			console.log('销毁后'); // 销毁后实例是没有变化的
			console.log(this.msg)  // 但是所有vue属性/指令销毁后...相关指令就不能再用了,比如在控制台输入app.msg='url'没有用，页面不显示
			console.log(this.$el)  
			console.log(document.getElementById('app').innerHTML) 
		}
	})
</script>

---mixing混入---
<div id="app">
	<button @click="add">add</button>

	{{ count }}<!-- name -->

	<button @click="sub">--</button>
	<button @click="ince">ince</button>
</div>
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
<script type="text/javascript">
	//全局混入
	Vue.mixin({
		data(){//混入的data不是一个对象。而是一个函数，在返回的对象中定义函数
			return {
				count:0
			}
		},
		methods:{
			add(){
				console.log('aaaa')
			}
		}
	})
	var obj = {
		methods:{
			sub(){
				console.log('--')
			}
		}
	}
	var obj2 = {
		methods:{
			ince(){
				console.log('++')
			}
		}
	}
	new Vue({
		el:'#app',
		data:{
			count: 2
		},
		methods:{
			add(){  //内部的会覆盖mixin的
				console.log(1)
			}
		},
		mixins: [obj,obj2]   // 局部混入
	})
</script>
---过滤器---
<div id='app'>
        {{msg|uppercase}}<!-- HELLO -->
        {{ss|lowercase}}<!-- byebye -->

    </div>
    <script>
        Vue.filter('uppercase',function(val){
            return val.toUpperCase()
        })
        new Vue({
            el:'#app',
            data:{
                msg:'hello',
                ss:'BYEBYE'
            },
            filters:{
                    'lowercase':function(val){
                        return val.toLowerCase()
                    }
                }           
    
        })
    </script>
-----------------------------------------------------10.28------------------------------------------------
	打开所在文件右键
	npm init -y
	npm i jquery
	npm i vue 开发和生产都需要用
	
	<div id="app">
	<ul>
		<li v-for="(item,index) in list" :key="index">{{item.area}}</li>
	</ul>
</div>
<script type="text/javascript" src="./node_modules/jquery/dist/jquery.js"></script>
<script type="text/javascript" src="./node_modules/vue/dist/vue.js"></script>
<script type="text/javascript">
	new Vue({
		el:'#app',
		data:{
			list:[]
		},
		mounted(){

			// console.log(this) //vue 实例
			// this.list = []

			var that = this;
			$.ajax({
				url:'https://api.i-lynn.cn/college',
				type:'get',
				success:function(data){
					var list = data.data.list;
					that.list = list
					// console.log(this) // $
				},
				error:function(err){
					console.log(err)
				}
			})
		}
	})
</script>

//get
 	axios.get('https://api.i-lynn.cn/college').then(res=>{
 		console.log(res)
 		/*
		 	res 包含以下属性
		 	config 配置对象
		 	data 返回回来的数据
		 	headers 请求头信息
		 	request 请求信息 用那种方式去请求的
		 	status 状态码
		 	statusText 状态码的文字提示信息

 		*/
 	})

 	// https://www.young1024.com:3002/news  


 	// post
 	axios.post('https://www.young1024.com:3002/news','type=NBA').then(res=>{
 		console.log(res)
 	})

// 获取新闻的列表
	// axios.post('https://www.young1024.com:3002/news','type=NBA').then(res=>{
 	// 		console.log(res)
 	// 	})

 	//搜索新闻
 	// axios.post('https://www.young1024.com:3002/search','keyword=基金').then(res=>{
 	// 	console.log(res)
 	// })
	
// 全局配置axios
 	// 配置接口的根地址
 	axios.defaults.baseURL="https://www.young1024.com:3002/";
 	axios.post('news','type=财经').then(res=>{
 		console.log(res)
 	})
	
axios 的拦截器：interceptors
拦截器一般做什么？
　　　　1. 修改请求头的一些配置项
　　　　2. 给请求的过程添加一些请求的图标
　　　　3. 给请求添加参数

axios.defaults.baseURL="https://www.young1024.com:3002/";
1. 全局的拦截器配置
axios.interceptors.request.use(function(config){
		// console.log(config)
		// config.data += '&name=young'

		// 把传递的参数改成对象形式 {name:young,age:18}
		// 在这个请求的拦截器中在改成 表单的形式 name=young&age=18
		// console.log(config.data)
		var params = ''
		for(item in config.data){
			// console.log(item)
			// console.log(config.data[item])
			params += item+'='+config.data[item]+'&'
		}
		// slice()
		params = params.substring(0,params.length-1)
		console.log(params)

		// 把转换后的参数再赋值给data
		config.data = params;


		return config;
	})

// 响应拦截
	axios.interceptors.response.use(function(res){
		console.log(res);
		res.data = res.data.data
		// res.data.push({name:'young',age:18})
		return res;
	})
	
axios.post('news',{type:'财经',size:30}).then(res=>{
		console.log(res)
	})
基于web留言板的设计与实现
学校表白墙管理系统

http://www.young1024.com:1234/#/details/5599
http://121.89.205.189/admindoc/

--------------------------------------------------------10.29----------------------------------------------------------
注册组件
<div id="app">
	<my></my>

	<my-com></my-com>

	<big-brother></big-brother>


	<jubu></jubu>




</div>

<script type="text/javascript" src="./node_modules/vue/dist/vue.js"></script>

<script type="text/javascript">
	
	// Vue.component() 
	// 参数1：组件名称 
	// 组件的配置对象 （以前在vue实例里面的选项都可以写在这里）
		// methods computed watch 生命周期的钩子
		//template 是组件要显示的内容  必须是只有一个根节点
	// 短横线的命名方式
	Vue.component('my-com',{
		template:'<h3>my-com</h3>'
	})
	// 大驼峰的命名方式 
	// 在使用的时候要把大写字母改成小写，然后单词之间要加上 -
	Vue.component('BigBrother',{
		template:'<h2>BigBrother   <big-second></big-second>  <my-com></my-com> </h2>',
		components:{
			'big-second':{
				template:'<h4>这是bigbrother里面的内容</h4>'
			}
		}
	})

	Vue.component('my',{
		data(){
			return {
				msg:'hello 组件'
			}
		},
		methods:{
			add(){
				console.log('add')
			}
		},
		template:'<div><h2>这是文字  {{msg}}  <button @click="add">add</button> </h2><h3>这是3</h3></div>'
	})

	new Vue({
		el:'#app',
		data:{

		},
		components:{  // 注册局部组件  key:组件名，value：组件配置对象
			'jubu':{
				template:'<h2>这是局部组件</h2>'
			}
		}
	})
</script>

1.子=>父 传值 绑定事件
<div id="app">//父亲
	<!-- (1)子组件自定义的事件，绑定父组件的方法 -->
	<child @myevent="myfun"></child>
</div>

<template id="child">
	<div>
		<h2>这是child组件</h2>
		{{num}}
		<button @click="num++">++</button>
		<button @click="up">up</button>
	</div>
</template>

<script type="text/javascript" src="./node_modules/vue/dist/vue.js"></script>

<script>
	Vue.component('child',{
		template:'#child',
		data(){
			return {
				num:3
			}
		},
		// (2)在子组件的某一个事件内部，通过this.$emit('自定义的事件名', 参数)完成传值
		methods:{
			up(){
				this.$emit('myevent',this.num)  
				//自定义事件
				// 参数1是事件名称
				// 参数2是向上传的值
			}
		}
	})
	new Vue({
		el:'#app',
		methods:{
			myfun(e){//父组件方法
				console.log('子组件触发的myevent事件')
				console.log('传上来的值：'+e)
			}
		}
	})
</script>

2.父=>子 传值 需要定义props
父组件以属性的形式绑定值到子组件身上
子组件通过使用属性props接收
props是单向绑定的（只读属性）：当父组件的属性变化时，将传导给子组件，但是反过来不会
props属性支持两种常见的写法形式数组(不可以设置默认值)和对象
<div id="app">
	<!-- salary="8000"  因为子组件没有定义salary 所以传进去也没用 -->
	<child name="young" age="19"></child>
	<child2 name="yy" :age="18"></child2>
	<hr>
	<child3></child3>
</div>

<template id="child">
	<div>
		<h2>这是child组件  </h2>

		<div>name: {{ name }}</div>
		<div>age: {{ age }}</div>
		<!-- <div> {{salary}}</div> -->
	</div>
</template>
<script type="text/javascript" src="./node_modules/vue/dist/vue.js"></script>
<script type="text/javascript">
	// 子组件需要接受值，就需要定义props
	Vue.component('child',{
		props:['name','age'],
		template:'#child'
	})	


	Vue.component('child2',{
		props:{
			name:String, //指定传值的类型为String
			age:Number //指定类型为Number
		},
		template:`<div>{{name}}{{age}}</div>`
	})


	Vue.component('child3',{
		props:{
			name: {  //  指定类型和默认值
				type: String,  // 类型
				default:'yy'  // 默认值
			},
			age: {
				type: Number,
				default: 18
			}
		},
		template:`<div>{{name}}{{age}}</div>`
	})

	new Vue({
		el:'#app'
	})
</script>

3.通过自定义事件给事件中心EventBus传递数据
<div id="app">
	<big></big>
	<hr>
	<small2></small2>

</div>

<template id="big">
	<div>
		<h2>这是big</h2>
		<div :style="{fontSize:num+'px'}">这是测试文字</div>
	</div>
</template>

<template id="samll">
	<div>
		<h2>samll</h2>
		<button @click="up">++</button>
	</div>
</template>

<script src="./node_modules/vue/dist/vue.js"></script>
<script>
	
	var bus = new Vue()	// 1.创建事件中心

	Vue.component('big',{
		template: '#big',
		data(){
			return {
				num:15
			}
		},
		mounted(){
			var that = this;
			bus.$on('grow',function(val){  // 通过监听事件中心的事件来接收数据
				console.log(val)
				that.num = val
			})
		}
	})
	Vue.component('small2',{
		template:'#samll',
		data(){
			return {
				size:15
			}
		},
		methods:{
			up(){
				this.size++;
				console.log(this.size)
				bus.$emit('grow',this.size)  // 2.通过自定义事件给事件中心传递数据
			}
		}
	})


	new Vue({
		el:'#app'
	})
</script>